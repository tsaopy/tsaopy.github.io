<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tsaopy.events API documentation</title>
<meta name="description" content="tsaopy Events submodule." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#ec6}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#66c;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#c96}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#906}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#ccf}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#cfc}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fc3}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tsaopy.events</code></h1>
</header>
<section id="section-intro">
<p>tsaopy Events submodule.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;tsaopy Events submodule.&#34;&#34;&#34;
import numpy as np
from tsaopy._f2pyauxmod import simulation


def _base_ll(pred, data, sigma):

    # discard diverging simulations
    if not np.isfinite(pred).all():
        return -np.inf

    return -.5 * np.sum(((pred - data) / sigma) ** 2)


#           tsaopy scripts
class Event:
    &#34;&#34;&#34;
    tsaopy Event class. Used to later instance tsaopy Model objects.

    The idea behind the Event class is to make it straightforward to fit the
    same equation of motion to different sets of measurements at the same time.

    Set up one Event instace for every set of (t, x{, v}) points.
    &#34;&#34;&#34;

    def __init__(self, params, t_data, x_data, x_sigma,
                 v_data=None, v_sigma=None, log_likelihood=None,
                 ll_params=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        params : dict
            dictionary containing the parameters relevant in the event. It&#39;s
            necessary to always include either x0 and v0 (initial conditions)
            or tt (time in transient state). If transient state is considered
            and initial conditions are not, then by default x0 and v0 are set
            to 0. Ideally, use time in transient state in driven oscillators.
            Optionally one can use ep for the equilibrium point for a series
            where it&#39;s equilibrium point is shifted from 0.

            Each entry in the dictionary should be defined with its key (&#39;tt&#39;,
            &#39;x0&#39;, &#39;v0&#39;, &#39;ep&#39;) and the value should be the prior for that parame
            ter.
        t_data : array
            array containing the time values. Values must be evenly spread.
        x_data : array
            array containing the position measurements. Must be of the same
            length as t_data.
        x_sigma : float or array
            uncertainty of the measurements. Can be a float with a unique value
            for all measurements, or an array of the same shape as x_data with
            a unique value for each value of x_data.
        v_data : array, optional
            array containing the velocity measurements. Must be of the same
            length as t_data.
        v_sigma : float or array, optional
            uncertainty of the measurements. Can be a float with a unique value
            for all measurements, or an array of the same shape as v_data with
            a unique value for each value of v_data. Necessary if v_data is
            being used.
        log_likelihood : callable, optional
            Optional parameter for including a custom logarithmic likelihood.
            See docs on how to set it up. The default is None.
        ll_params : dict, optional
            A dictionary with extra parameters used by the custom log likelihoo
            d. Use a label for keys and a prior for the value. The default is
            None.

        Examples
        --------
            import numpy as np
            import tsaopy
            import quickemcee as qmc

            t = np.linspace(0, 10, 101)
            x = np.cos(t) + np.random.normal(.0, .3, 101) # data with noise
            x_noise = .3

            x0_prior = qmc.utils.normal_prior(1.0, 10.0)
            v0_prior = qmc.utils.normal_prior(.0, 10.0)

            params_dict = {&#39;x0&#39;: x0_prior,
                           &#39;v0&#39;: v0_prior
                           }

            event1 = tsaopy.events.Event(params_dict, t, x, x_noise)

        &#34;&#34;&#34;
        #           TO DO HERE: error handling

        #       Define core attributes ~~~~
        self.ndim = len(params)
        self.tsplit = 2
        self.datalen = len(t_data)
        self.dt = np.float128((t_data[-1] - t_data[0]) / (self.datalen - 1))

        # attibute priors
        self.priors = []

        # do checks in coefs
        # tt
        if &#39;tt&#39; in params:
            self.using_tt = True
            self.priors.append(params[&#39;tt&#39;])
        else:
            self.using_tt = False

        # x0v0
        if (&#39;x0&#39; in params and &#39;v0&#39; in params):
            self.using_x0v0 = True
            self.priors.append(params[&#39;x0&#39;])
            self.priors.append(params[&#39;v0&#39;])
        else:
            self.using_x0v0 = False

        # ep
        if &#39;ep&#39; in params:
            self.using_ep = True
            self.priors.append(params[&#39;ep&#39;])
        else:
            self.using_ep = False

        # save observations &amp; sigma data
        self.t0, self.tf = t_data[0], t_data[-1]
        self.x_data = x_data
        self.x_sigma = x_sigma

        if not (v_data is None or v_sigma is None):
            self.fit_to_v = True
            self.v_data = v_data
            self.v_sigma = v_sigma
        else:
            self.fit_to_v = False

        # log likelihood
        if log_likelihood is None:
            self.use_custom_ll = False
        else:
            self.use_custom_ll = True
            self.custom_ll = log_likelihood

        if ll_params is None:
            self.custom_ll_params = False
        else:
            self.custom_ll_params = True
            self.custom_ll_params_labels = [_ for _ in ll_params]
            self.priors += [ll_params[_] for _ in ll_params]
            self.cllp_ndim = len(ll_params)
            self.ndim += self.cllp_ndim

    #  methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def _predict(self, A, B, C, df, df_params, tt, x0v0, ep):
        &#34;&#34;&#34;Compute tsaopy prediction using coefs and iniconds.&#34;&#34;&#34;
        fit_to_v = self.fit_to_v

        tsplit = self.tsplit
        dt = self.dt / tsplit

        t0, tf = self.t0 - tt, self.tf
        if not self.using_tt and self.using_x0v0:
            datalen = (self.datalen - 1) * tsplit + 1
        elif self.using_tt:
            datalen = int((tf - t0) / dt) + 1
            if datalen &lt; (self.datalen - 1) * tsplit + 1:
                datalen += 1

        na, nb = len(A), len(B)
        cn, cm = C.shape
        nf = 2 * (datalen - 1) + 1
        t_array = np.linspace(t0, tf, nf)
        F = df(t_array, df_params)

        if cn == 0 or cm == 0:
            cn, cm, C = 1, 1, np.zeros(1)

        pred = simulation(a_in=A, b_in=B, c_in=C, f_in=F, x_in=x0v0,
                          na=na, nb=nb, cn=cn, cm=cm, nf=nf,
                          datalen=datalen, dt=dt)[::tsplit][-self.datalen:]
        predx, predv = pred[:, 0], pred[:, 1]

        if not fit_to_v:
            return predx + ep
        elif fit_to_v:
            return predx + ep, predv

    def _default_ll(self, pred):
        &#34;&#34;&#34;Default log likelihood.&#34;&#34;&#34;
        if not self.fit_to_v:
            return _base_ll(pred, self.x_data, self.x_sigma)
        elif self.fit_to_v:
            return (_base_ll(pred[0], self.x_data, self.x_sigma)
                    + _base_ll(pred[1], self.v_data, self.v_sigma))

    def _log_likelihood(self, A, B, C, df, df_params,
                        tt, x0v0, ep,
                        ll_params):
        &#34;&#34;&#34;Compute log likelihood for event parameters and ODE coefs arrays.&#34;&#34;&#34;
        pred = self._predict(A, B, C, df, df_params, tt, x0v0, ep)

        if not self.use_custom_ll:
            return self._default_ll(pred)
        elif self.use_custom_ll and self.custom_ll_params:
            return self.custom_ll(self, pred, ll_params)
        elif self.use_custom_ll and not self.custom_ll_params:
            return self.custom_ll(self, pred)

    def _log_prior(self, event_coords):
        &#34;&#34;&#34;Compute log prior for event parameters.&#34;&#34;&#34;
        result = 1
        for i, p in enumerate(self.priors):
            prob = p(event_coords[i])
            if prob &lt;= .0:
                return -np.inf
            result *= prob
        return np.log(result)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tsaopy.events.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>params, t_data, x_data, x_sigma, v_data=None, v_sigma=None, log_likelihood=None, ll_params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>tsaopy Event class. Used to later instance tsaopy Model objects.</p>
<p>The idea behind the Event class is to make it straightforward to fit the
same equation of motion to different sets of measurements at the same time.</p>
<p>Set up one Event instace for every set of (t, x{, v}) points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>dictionary containing the parameters relevant in the event. It's
necessary to always include either x0 and v0 (initial conditions)
or tt (time in transient state). If transient state is considered
and initial conditions are not, then by default x0 and v0 are set
to 0. Ideally, use time in transient state in driven oscillators.
Optionally one can use ep for the equilibrium point for a series
where it's equilibrium point is shifted from 0.</p>
<p>Each entry in the dictionary should be defined with its key ('tt',
'x0', 'v0', 'ep') and the value should be the prior for that parame
ter.</p>
</dd>
<dt><strong><code>t_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array containing the time values. Values must be evenly spread.</dd>
<dt><strong><code>x_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array containing the position measurements. Must be of the same
length as t_data.</dd>
<dt><strong><code>x_sigma</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>uncertainty of the measurements. Can be a float with a unique value
for all measurements, or an array of the same shape as x_data with
a unique value for each value of x_data.</dd>
<dt><strong><code>v_data</code></strong> :&ensp;<code>array</code>, optional</dt>
<dd>array containing the velocity measurements. Must be of the same
length as t_data.</dd>
<dt><strong><code>v_sigma</code></strong> :&ensp;<code>float</code> or <code>array</code>, optional</dt>
<dd>uncertainty of the measurements. Can be a float with a unique value
for all measurements, or an array of the same shape as v_data with
a unique value for each value of v_data. Necessary if v_data is
being used.</dd>
<dt><strong><code>log_likelihood</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>Optional parameter for including a custom logarithmic likelihood.
See docs on how to set it up. The default is None.</dd>
<dt><strong><code>ll_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A dictionary with extra parameters used by the custom log likelihoo
d. Use a label for keys and a prior for the value. The default is
None.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>import numpy as np
import tsaopy
import quickemcee as qmc

t = np.linspace(0, 10, 101)
x = np.cos(t) + np.random.normal(.0, .3, 101) # data with noise
x_noise = .3

x0_prior = qmc.utils.normal_prior(1.0, 10.0)
v0_prior = qmc.utils.normal_prior(.0, 10.0)

params_dict = {'x0': x0_prior,
               'v0': v0_prior
               }

event1 = tsaopy.events.Event(params_dict, t, x, x_noise)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Event:
    &#34;&#34;&#34;
    tsaopy Event class. Used to later instance tsaopy Model objects.

    The idea behind the Event class is to make it straightforward to fit the
    same equation of motion to different sets of measurements at the same time.

    Set up one Event instace for every set of (t, x{, v}) points.
    &#34;&#34;&#34;

    def __init__(self, params, t_data, x_data, x_sigma,
                 v_data=None, v_sigma=None, log_likelihood=None,
                 ll_params=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        params : dict
            dictionary containing the parameters relevant in the event. It&#39;s
            necessary to always include either x0 and v0 (initial conditions)
            or tt (time in transient state). If transient state is considered
            and initial conditions are not, then by default x0 and v0 are set
            to 0. Ideally, use time in transient state in driven oscillators.
            Optionally one can use ep for the equilibrium point for a series
            where it&#39;s equilibrium point is shifted from 0.

            Each entry in the dictionary should be defined with its key (&#39;tt&#39;,
            &#39;x0&#39;, &#39;v0&#39;, &#39;ep&#39;) and the value should be the prior for that parame
            ter.
        t_data : array
            array containing the time values. Values must be evenly spread.
        x_data : array
            array containing the position measurements. Must be of the same
            length as t_data.
        x_sigma : float or array
            uncertainty of the measurements. Can be a float with a unique value
            for all measurements, or an array of the same shape as x_data with
            a unique value for each value of x_data.
        v_data : array, optional
            array containing the velocity measurements. Must be of the same
            length as t_data.
        v_sigma : float or array, optional
            uncertainty of the measurements. Can be a float with a unique value
            for all measurements, or an array of the same shape as v_data with
            a unique value for each value of v_data. Necessary if v_data is
            being used.
        log_likelihood : callable, optional
            Optional parameter for including a custom logarithmic likelihood.
            See docs on how to set it up. The default is None.
        ll_params : dict, optional
            A dictionary with extra parameters used by the custom log likelihoo
            d. Use a label for keys and a prior for the value. The default is
            None.

        Examples
        --------
            import numpy as np
            import tsaopy
            import quickemcee as qmc

            t = np.linspace(0, 10, 101)
            x = np.cos(t) + np.random.normal(.0, .3, 101) # data with noise
            x_noise = .3

            x0_prior = qmc.utils.normal_prior(1.0, 10.0)
            v0_prior = qmc.utils.normal_prior(.0, 10.0)

            params_dict = {&#39;x0&#39;: x0_prior,
                           &#39;v0&#39;: v0_prior
                           }

            event1 = tsaopy.events.Event(params_dict, t, x, x_noise)

        &#34;&#34;&#34;
        #           TO DO HERE: error handling

        #       Define core attributes ~~~~
        self.ndim = len(params)
        self.tsplit = 2
        self.datalen = len(t_data)
        self.dt = np.float128((t_data[-1] - t_data[0]) / (self.datalen - 1))

        # attibute priors
        self.priors = []

        # do checks in coefs
        # tt
        if &#39;tt&#39; in params:
            self.using_tt = True
            self.priors.append(params[&#39;tt&#39;])
        else:
            self.using_tt = False

        # x0v0
        if (&#39;x0&#39; in params and &#39;v0&#39; in params):
            self.using_x0v0 = True
            self.priors.append(params[&#39;x0&#39;])
            self.priors.append(params[&#39;v0&#39;])
        else:
            self.using_x0v0 = False

        # ep
        if &#39;ep&#39; in params:
            self.using_ep = True
            self.priors.append(params[&#39;ep&#39;])
        else:
            self.using_ep = False

        # save observations &amp; sigma data
        self.t0, self.tf = t_data[0], t_data[-1]
        self.x_data = x_data
        self.x_sigma = x_sigma

        if not (v_data is None or v_sigma is None):
            self.fit_to_v = True
            self.v_data = v_data
            self.v_sigma = v_sigma
        else:
            self.fit_to_v = False

        # log likelihood
        if log_likelihood is None:
            self.use_custom_ll = False
        else:
            self.use_custom_ll = True
            self.custom_ll = log_likelihood

        if ll_params is None:
            self.custom_ll_params = False
        else:
            self.custom_ll_params = True
            self.custom_ll_params_labels = [_ for _ in ll_params]
            self.priors += [ll_params[_] for _ in ll_params]
            self.cllp_ndim = len(ll_params)
            self.ndim += self.cllp_ndim

    #  methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def _predict(self, A, B, C, df, df_params, tt, x0v0, ep):
        &#34;&#34;&#34;Compute tsaopy prediction using coefs and iniconds.&#34;&#34;&#34;
        fit_to_v = self.fit_to_v

        tsplit = self.tsplit
        dt = self.dt / tsplit

        t0, tf = self.t0 - tt, self.tf
        if not self.using_tt and self.using_x0v0:
            datalen = (self.datalen - 1) * tsplit + 1
        elif self.using_tt:
            datalen = int((tf - t0) / dt) + 1
            if datalen &lt; (self.datalen - 1) * tsplit + 1:
                datalen += 1

        na, nb = len(A), len(B)
        cn, cm = C.shape
        nf = 2 * (datalen - 1) + 1
        t_array = np.linspace(t0, tf, nf)
        F = df(t_array, df_params)

        if cn == 0 or cm == 0:
            cn, cm, C = 1, 1, np.zeros(1)

        pred = simulation(a_in=A, b_in=B, c_in=C, f_in=F, x_in=x0v0,
                          na=na, nb=nb, cn=cn, cm=cm, nf=nf,
                          datalen=datalen, dt=dt)[::tsplit][-self.datalen:]
        predx, predv = pred[:, 0], pred[:, 1]

        if not fit_to_v:
            return predx + ep
        elif fit_to_v:
            return predx + ep, predv

    def _default_ll(self, pred):
        &#34;&#34;&#34;Default log likelihood.&#34;&#34;&#34;
        if not self.fit_to_v:
            return _base_ll(pred, self.x_data, self.x_sigma)
        elif self.fit_to_v:
            return (_base_ll(pred[0], self.x_data, self.x_sigma)
                    + _base_ll(pred[1], self.v_data, self.v_sigma))

    def _log_likelihood(self, A, B, C, df, df_params,
                        tt, x0v0, ep,
                        ll_params):
        &#34;&#34;&#34;Compute log likelihood for event parameters and ODE coefs arrays.&#34;&#34;&#34;
        pred = self._predict(A, B, C, df, df_params, tt, x0v0, ep)

        if not self.use_custom_ll:
            return self._default_ll(pred)
        elif self.use_custom_ll and self.custom_ll_params:
            return self.custom_ll(self, pred, ll_params)
        elif self.use_custom_ll and not self.custom_ll_params:
            return self.custom_ll(self, pred)

    def _log_prior(self, event_coords):
        &#34;&#34;&#34;Compute log prior for event parameters.&#34;&#34;&#34;
        result = 1
        for i, p in enumerate(self.priors):
            prob = p(event_coords[i])
            if prob &lt;= .0:
                return -np.inf
            result *= prob
        return np.log(result)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<h3>Return to the project's <a href="https://tsaopy.github.io/">homepage</a></h3
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsaopy" href="index.html">tsaopy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tsaopy.events.Event" href="#tsaopy.events.Event">Event</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
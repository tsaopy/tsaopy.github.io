<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tsaopy.models API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tsaopy.models</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import numpy as np
from multiprocessing import cpu_count, Pool
from matplotlib import pyplot as plt
import emcee

from tsaopy._f2pyauxmod import simulation, simulationv
from tsaopy._bendtools import (fitparams_info, params_array_shape,
                               test_params_are_ok)

# model classes


class PModel:
    &#34;&#34;&#34;
    Build `tsaopy` model object.

    This object condenses all necessary variables to set up the ODE according
    to the parameters provided plus the MCMC configuration to do the fitting.

    It includes some QOL methods suchs as changing the initial values of the
    chain, the time step for the simulations, the number of CPU cores used
    during simulations, and type of emcee moves used in the MCMC chain. It also
    includes some plotting methods.

    This class only uses x(t) information for the fitting.
    &#34;&#34;&#34;

    def __init__(self, parameters, t_data, x_data, x_unc):
        &#34;&#34;&#34;
        Parameters
        ----------
        parameters : list
            the list of parameters that will be considered in the model. There
            must be at least three parameters including the initial conditions
            and one ODE coefficient. There can&#39;t be repeated parameters (two
            parameters having the same ptype and index).
        t_data : array
            array with the time axis of the measurements..
        x_data : array
            array with the position measurements.
        x_unc : float or int, or array
            uncertainty of your measurements. It can be either a single number
            representing the uncertainty of all measurements or an array of the
            same length as x_data with a unique value for each measurement.
        &#34;&#34;&#34;
        test_params_are_ok(parameters)

        self.parameters = parameters
        self.t_data = t_data
        self.x_data = x_data
        self.x_unc = x_unc

        self.datalen = len(t_data)
        self.t0 = t_data[0]
        self.tsplit = 4
        self.dt = (t_data[-1] - self.t0) / (self.datalen - 1) / self.tsplit

        self.params_to_fit = [p for p in parameters if not p.fixed]
        self.ndim = len(self.params_to_fit)
        self.mcmc_initvals = [p.value for p in self.params_to_fit]
        self.ptf_info, self.params_labels = fitparams_info(self.params_to_fit)
        self.priors_array = [p.prior for p in self.params_to_fit]

        self.parray_shape = params_array_shape(self.parameters)
        self.alens = (self.parray_shape[0][0],
                      self.parray_shape[1][0],
                      self.parray_shape[2][0],
                      self.parray_shape[2][1])

        self.fx_fix = False
        for p in self.params_to_fit:
            if p.ptype == &#39;log_fx&#39;:
                self.fx_fix = True
                self.log_fx_loc = self.params_to_fit.index(p)

        self.mcmc_moves = None
        if cpu_count() &gt; 2:
          self.cpu_cores = cpu_count() - 2
        else:
          self.cpu_cores = 1

    # simulations

    def _setup_simulation_arrays(self, coords):
        &#34;&#34;&#34;Set up the parameters array used by a simulation.&#34;&#34;&#34;
        na, nb, cn, cm, = self.alens
        scalars, A, B, C, F = (np.zeros(3), np.zeros(na), np.zeros(nb),
                               np.zeros((cn, cm)), np.zeros(3))

        for p in self.parameters:
            if p.ptype == &#34;ep&#34;:
                scalars[0] = p.value
            if p.ptype == &#34;x0&#34;:
                scalars[1] = p.value
            elif p.ptype == &#34;v0&#34;:
                scalars[2] = p.value
            elif p.ptype == &#34;a&#34;:
                A[p.index - 1] = p.value
            elif p.ptype == &#34;b&#34;:
                B[p.index - 1] = p.value
            elif p.ptype == &#34;c&#34;:
                q = p.index
                C[(q[0] - 1, q[1] - 1)] = p.value
            elif p.ptype == &#34;f&#34;:
                F[p.index - 1] = p.value

        results = [scalars, A, B, C, F]
        ptf_index_info = self.ptf_info

        for q in ptf_index_info:
            if q is not None:
                i = ptf_index_info.index(q)
                results[q[0]][q[1]] = coords[i]

        return results

    def _predict(self, coords):
        &#34;&#34;&#34;Compute x(t) for a set of parameter values.&#34;&#34;&#34;
        dt, tsplit, datalen = self.dt, self.tsplit, self.datalen
        na, nb, cn, cm, = self.alens

        epx0v0_simu, A_simu, B_simu, C_simu, F_simu = (
                                        self._setup_simulation_arrays(coords))

        ep_simu, x0v0_simu = epx0v0_simu[0], epx0v0_simu[1:3]

        return simulation(x0v0_simu, A_simu, B_simu, C_simu, F_simu,
                          dt, tsplit * datalen, na, nb, cn, cm
                          )[::tsplit] + ep_simu

    # mcmc stuff

    def _log_prior(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic prior of a set of parameter values.&#34;&#34;&#34;
        result = 1
        for i in range(self.ndim):
            prob = self.priors_array[i](coefs[i])
            if prob &lt;= 0:
                return -np.inf
            else:
                result = result * prob
        return np.log(result)

    def _log_likelihood(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic likelihood of a set of parameter values.&#34;&#34;&#34;
        prediction = self._predict(coefs)
        if not np.isfinite(prediction[-1]):
            return -np.inf

        if self.fx_fix:
            log_fx = coefs[self.log_fx_loc]
            s2 = self.x_unc ** 2 + prediction ** 2 * np.exp(2 * log_fx)
            ll = - 0.5 * np.sum((prediction - self.x_data) ** 2 / s2 +
                                np.log(s2))
        else:
            ll = - 0.5 * np.sum(((prediction - self.x_data) / self.x_unc) ** 2)
        return ll

    def _log_probability(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic probabilty of a set of parameter values.&#34;&#34;&#34;
        lp = self._log_prior(coefs)
        if not np.isfinite(lp):
            return -np.inf
        return lp + self._log_likelihood(coefs)

    def setup_sampler(self, n_walkers, burn_iter, main_iter):
        &#34;&#34;&#34;
        Set up the `emcee` Sampler object and run the MCMC chain.

        See `emcee` docs for more details.

        Parameters such as the number of CPU cores and `emcee` moves used by
        the sampler can be changed from the model attributes before running
        this method. See the full docs of the model classes for more details.

        Parameters
        ----------
        n_walkers : int
            the number of walkers in the MCMC chain. See `emcee` docs for more
            details.
        burn_iter : int
            the number of steps that your chain will do during the burn in
            phase. The samples produced during burn in phase are discarded.
        main_iter : int
            the number of steps that your chain will do during the production
            phase. The samples produced during production phase are saved in
            the sampler and can be extracted for later analysis.

        Returns
        -------
        sampler : emcee Sampler instance
            Returns the `emcee` ensemble sampler after running MCMC. See
            `emcee` docs for more details.
        &#34;&#34;&#34;
        p0 = [self.mcmc_initvals + 1e-7 * np.random.randn(self.ndim)
              for i in range(n_walkers)]

        with Pool(processes=self.cpu_cores) as pool:
            sampler = emcee.EnsembleSampler(n_walkers, self.ndim,
                                            self._log_probability,
                                            moves=self.mcmc_moves, pool=pool)

            print(&#34;&#34;)
            print(&#34;Running burn-in...&#34;)
            p0, _, _ = sampler.run_mcmc(p0, burn_iter, progress=True)
            sampler.reset()

            print(&#34;&#34;)
            print(&#34;Running production...&#34;)
            pos, prob, state = sampler.run_mcmc(p0, main_iter, progress=True)

            return sampler

    # tools

    def update_initvals(self, newinivalues):
        &#34;&#34;&#34;
        Update the starting values of the MCMC chain.

        Update the initial values of the MCMC chain stored in the `tsaopy`
        model instance `mcmc_initvals` attribute. Default is a list with the
        value attribute for each parameter supplied to the model at
        initialization.

        This attribute is supplied to the `emcee` Sampler object when
        `setup_sampler`.

        Parameters
        ----------
        newinivalues : list or array
            the new values for the initial  values of the MCMC chain. The
            elements must be passed in the same order than the parameters
            arg that was passed when initializing the model.
        &#34;&#34;&#34;
        self.mcmc_initvals = newinivalues

    def set_mcmc_moves(self, moves):
        &#34;&#34;&#34;
        Change the `emcee` moves used in the MCMC run.

        Set the mcmc_moves attribute in the `tsaopy` model instance. Default is
        None. This attribute is supplied to the `emcee` Sampler object when the
        setup_sampler method of the `tsaopy` model object is called. It&#39;s
        possible to run MCMC chains for the same model with different moves by
        updating the attribute with this method before each chain is run.

        Parameters
        ----------
        moves : emcee moves instance
            the `emcee` moves instance to be supplied to the sampler.


        &#34;&#34;&#34;
        self.mcmc_moves = moves

    def set_cpu_cores(self, cores):
        &#34;&#34;&#34;
        Set the number of CPU cores used by the emcee sampler.

        Set the cpu_cores attribute in the `tsaopy` model instance. Default is
        the total number of cores in the system, obtained with
        `multiprocessing.cpu_count`, minus two, or one if `cpu_count` returns 2
        or less.

        This attribute is supplied to the emcee Sampler object when you call
        the setup_sampler method of the tsaopy model object.

        Parameters
        ----------
        cores : int
            number of CPU cores to be used by the `emcee` sampler.
        &#34;&#34;&#34;
        self.cpu_cores = cores

    def update_tsplit(self, newtsplit):
        &#34;&#34;&#34;
        Change the integration time in simulations.

        Set the `tsplit` attribute in the `tsaopy` model instance, which is
        used to set the time step for the numerical integrations.

        The time step in the numerical integration is computed as

        dt = (tf - t0)/(ndata-1)/tsplit

        This means that the time step is obtained by dividing the difference
        between consecutive t values over `tsplit`. Default value is 4.
        Users that want to improve computing time may reduce this attribute
        to 3, 2, or 1, at the expense of a possible precission loss in the
        numerical simulations.

        Parameters
        ----------
        newtsplit : int
            the new value for tsplit that will also update the integration
            time step.
        &#34;&#34;&#34;
        self.tsplit = newtsplit
        self.dt = (self.t_data[-1] - self.t0) / (
                                                self.datalen - 1) / self.tsplit

    def neg_ll(self, coords):
        &#34;&#34;&#34;
        Compute the negative logarithmic likelihood.

        Compute the negative logarithmic likelihood for a set of parameter
        values for the defined model. This is best used when optimizing the
        initial values with an external optimizer.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.

        Returns
        -------
        float
            value of `neg_ll` for the given parameter values.

        Examples
        -------
            f_to_minimize = my_model.neg_ll
            external_function_minimizer(f_to_minimize, *args)
        &#34;&#34;&#34;
        return -self._log_likelihood(coords)

    # plots

    def plot_measurements(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
            )
        plt.legend()
        plt.show()

    def plot_simulation(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model,
        and a lineplot of a simulation using values provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
            )
        plt.plot(
            self.t_data, self._predict(coords),
            color=&#34;tab:red&#34;, label=&#34;x simulation&#34;
            )
        plt.legend()
        plt.show()

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


class PVModel(PModel):
    &#34;&#34;&#34;
    Build `tsaopy` model object.

    This object condenses all necessary variables to set up the ODE according
    to the parameters provided plus the MCMC configuration to do the fitting.

    It includes some QOL methods suchs as changing the initial values of the
    chain, the time step for the simulations, the number of CPU cores used
    during simulations, and type of emcee moves used in the MCMC chain. It also
    includes some plotting methods.

    This class fits the parameters to both x(t) and v(t) data.
    &#34;&#34;&#34;

    def __init__(self, parameters, t_data, x_data, v_data, x_unc, v_unc):
        &#34;&#34;&#34;
        Parameters
        ----------
        parameters : list
            the list of parameters that will be considered in the model. There
            must be at least three parameters including the initial conditions
            and one ODE coefficient. There can&#39;t be repeated parameters (two
            parameters having the same ptype and index).
        t_data : array
            array with the time axis of the measurements.
        x_data : array
            array with the position measurements.
        v_data : array
            array with the velocity measurements. Note that there can&#39;t be a
            scale factor between x(t) and v(t), v(t) must be exactly equal
            to the time derivative of x(t).
        x_unc : float or int, or array
            uncertainty of the x(t) measurements. It can be either a single
            number representing the uncertainty of all measurements or an array
            of the same length as `x_data` with a unique value for each
            measurement.
        v_unc : float or int, or array
            same as `x_unc` but for v(t) measurements.
        &#34;&#34;&#34;
        super().__init__(parameters, t_data, x_data, x_unc)
        self.v_data = v_data
        self.v_unc = v_unc
        self.fv_fix = False
        for p in self.params_to_fit:
            if p.ptype == &#39;log_fv&#39;:
                self.fv_fix = True
                self.log_fv_loc = self.params_to_fit.index(p)

    def _predict(self, coords):
        &#34;&#34;&#34;Compute x(t) and v(t) for a set of parameter values.&#34;&#34;&#34;
        dt, tsplit, datalen = self.dt, self.tsplit, self.datalen
        na, nb, cn, cm, = self.alens

        epx0v0_simu, A_simu, B_simu, C_simu, F_simu = (
                                        self._setup_simulation_arrays(coords))

        ep_simu, x0v0_simu = epx0v0_simu[0], epx0v0_simu[1:]

        simu_result = simulationv(x0v0_simu, A_simu, B_simu, C_simu, F_simu,
                                  dt, tsplit * datalen, na, nb, cn,
                                  cm)[::tsplit]

        simu_result[:, 0] = simu_result[:, 0] + ep_simu
        return simu_result

    def _log_likelihood(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic likelihood of a set of parameter values.&#34;&#34;&#34;
        prediction = self._predict(coefs)
        predx, predv = prediction[:, 0], prediction[:, 1]
        if not np.isfinite(predv[-1]):
            return -np.inf

        if self.fx_fix:
            log_fx = coefs[self.log_fx_loc]
            s2_x = self.x_unc ** 2 + predx ** 2 * np.exp(2 * log_fx)
            ll = - 0.5 * np.sum((predx - self.x_data) ** 2 / s2_x +
                                np.log(s2_x))
        else:
            ll = - 0.5 * np.sum(((predx - self.x_data) / self.x_unc) ** 2)

        if self.fv_fix:
            log_fv = coefs[self.log_fv_loc]
            s2_v = self.v_unc ** 2 + predv ** 2 * np.exp(2 * log_fv)
            ll = ll - 0.5 * np.sum((predv - self.v_data) ** 2 / s2_v +
                                   np.log(s2_v))
        else:
            ll = ll - 0.5 * np.sum(((predv - self.v_data) / self.v_unc) ** 2)

        return ll

    def _log_probability(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic probability of a set of parameter values.&#34;&#34;&#34;
        lp = self._log_prior(coefs)
        if not np.isfinite(lp):
            return -np.inf
        return lp + self._log_likelihood(coefs)

    def setup_sampler(self, n_walkers, burn_iter, main_iter):
        &#34;&#34;&#34;
        Set up the `emcee` Sampler object and run the MCMC chain.

        See `emcee` docs for more details.

        Parameters such as the number of CPU cores and `emcee` moves used by
        the sampler can be changed from the model attributes before running
        this method. See the full docs of the model classes for more details.

        Parameters
        ----------
        n_walkers : int
            the number of walkers in the MCMC chain. See `emcee` docs for more
            details.
        burn_iter : int
            the number of steps that your chain will do during the burn in
            phase. The samples produced during burn in phase are discarded.
        main_iter : int
            the number of steps that your chain will do during the production
            phase. The samples produced during production phase are saved in
            the sampler and can be extracted for later analysis.

        Returns
        -------
        sampler : emcee Sampler instance
            Returns the `emcee` ensemble sampler after running MCMC. See
            `emcee` docs for more details.
        &#34;&#34;&#34;
        p0 = [self.mcmc_initvals + 1e-7 * np.random.randn(self.ndim)
              for i in range(n_walkers)]

        with Pool(processes=self.cpu_cores) as pool:
            sampler = emcee.EnsembleSampler(n_walkers, self.ndim,
                                            self._log_probability,
                                            moves=self.mcmc_moves, pool=pool)

            print(&#34;&#34;)
            print(&#34;Running burn-in...&#34;)
            p0, _, _ = sampler.run_mcmc(p0, burn_iter, progress=True)
            sampler.reset()

            print(&#34;&#34;)
            print(&#34;Running production...&#34;)
            pos, prob, state = sampler.run_mcmc(p0, main_iter, progress=True)

            return sampler

    # tools

    def neg_ll(self, coords):
        &#34;&#34;&#34;See docs for PModel.&#34;&#34;&#34;
        return -self._log_likelihood(coords)

    # plots

    def plot_measurements(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
        provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.legend()
        plt.show()

    def plot_measurements_x(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.legend()
        plt.show()

    def plot_measurements_v(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,v(t)) series provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.legend()
        plt.show()

    def plot_simulation(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
        provided to the model, and lineplots of a simulation using values
        provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 0],
            color=&#34;tab:red&#34;,
            label=&#34;x simulation&#34;,
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 1],
            color=&#34;tab:purple&#34;,
            label=&#34;v simulation&#34;,
        )
        plt.legend()
        plt.show()

    def plot_simulation_x(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model,
        and a lineplot of a simulation using values provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 0],
            color=&#34;tab:red&#34;,
            label=&#34;x simulation&#34;,
        )
        plt.legend()
        plt.show()

    def plot_simulation_v(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,v(t)) series provided to the model,
        and a lineplot of a simulation using values provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 1],
            color=&#34;tab:purple&#34;,
            label=&#34;v simulation&#34;,
        )
        plt.legend()
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tsaopy.models.PModel"><code class="flex name class">
<span>class <span class="ident">PModel</span></span>
<span>(</span><span>parameters, t_data, x_data, x_unc)</span>
</code></dt>
<dd>
<div class="desc"><p>Build <code><a title="tsaopy" href="index.html">tsaopy</a></code> model object.</p>
<p>This object condenses all necessary variables to set up the ODE according
to the parameters provided plus the MCMC configuration to do the fitting.</p>
<p>It includes some QOL methods suchs as changing the initial values of the
chain, the time step for the simulations, the number of CPU cores used
during simulations, and type of emcee moves used in the MCMC chain. It also
includes some plotting methods.</p>
<p>This class only uses x(t) information for the fitting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list</code></dt>
<dd>the list of parameters that will be considered in the model. There
must be at least three parameters including the initial conditions
and one ODE coefficient. There can't be repeated parameters (two
parameters having the same ptype and index).</dd>
<dt><strong><code>t_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with the time axis of the measurements..</dd>
<dt><strong><code>x_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with the position measurements.</dd>
<dt><strong><code>x_unc</code></strong> :&ensp;<code>float</code> or <code>int,</code> or <code>array</code></dt>
<dd>uncertainty of your measurements. It can be either a single number
representing the uncertainty of all measurements or an array of the
same length as x_data with a unique value for each measurement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PModel:
    &#34;&#34;&#34;
    Build `tsaopy` model object.

    This object condenses all necessary variables to set up the ODE according
    to the parameters provided plus the MCMC configuration to do the fitting.

    It includes some QOL methods suchs as changing the initial values of the
    chain, the time step for the simulations, the number of CPU cores used
    during simulations, and type of emcee moves used in the MCMC chain. It also
    includes some plotting methods.

    This class only uses x(t) information for the fitting.
    &#34;&#34;&#34;

    def __init__(self, parameters, t_data, x_data, x_unc):
        &#34;&#34;&#34;
        Parameters
        ----------
        parameters : list
            the list of parameters that will be considered in the model. There
            must be at least three parameters including the initial conditions
            and one ODE coefficient. There can&#39;t be repeated parameters (two
            parameters having the same ptype and index).
        t_data : array
            array with the time axis of the measurements..
        x_data : array
            array with the position measurements.
        x_unc : float or int, or array
            uncertainty of your measurements. It can be either a single number
            representing the uncertainty of all measurements or an array of the
            same length as x_data with a unique value for each measurement.
        &#34;&#34;&#34;
        test_params_are_ok(parameters)

        self.parameters = parameters
        self.t_data = t_data
        self.x_data = x_data
        self.x_unc = x_unc

        self.datalen = len(t_data)
        self.t0 = t_data[0]
        self.tsplit = 4
        self.dt = (t_data[-1] - self.t0) / (self.datalen - 1) / self.tsplit

        self.params_to_fit = [p for p in parameters if not p.fixed]
        self.ndim = len(self.params_to_fit)
        self.mcmc_initvals = [p.value for p in self.params_to_fit]
        self.ptf_info, self.params_labels = fitparams_info(self.params_to_fit)
        self.priors_array = [p.prior for p in self.params_to_fit]

        self.parray_shape = params_array_shape(self.parameters)
        self.alens = (self.parray_shape[0][0],
                      self.parray_shape[1][0],
                      self.parray_shape[2][0],
                      self.parray_shape[2][1])

        self.fx_fix = False
        for p in self.params_to_fit:
            if p.ptype == &#39;log_fx&#39;:
                self.fx_fix = True
                self.log_fx_loc = self.params_to_fit.index(p)

        self.mcmc_moves = None
        if cpu_count() &gt; 2:
          self.cpu_cores = cpu_count() - 2
        else:
          self.cpu_cores = 1

    # simulations

    def _setup_simulation_arrays(self, coords):
        &#34;&#34;&#34;Set up the parameters array used by a simulation.&#34;&#34;&#34;
        na, nb, cn, cm, = self.alens
        scalars, A, B, C, F = (np.zeros(3), np.zeros(na), np.zeros(nb),
                               np.zeros((cn, cm)), np.zeros(3))

        for p in self.parameters:
            if p.ptype == &#34;ep&#34;:
                scalars[0] = p.value
            if p.ptype == &#34;x0&#34;:
                scalars[1] = p.value
            elif p.ptype == &#34;v0&#34;:
                scalars[2] = p.value
            elif p.ptype == &#34;a&#34;:
                A[p.index - 1] = p.value
            elif p.ptype == &#34;b&#34;:
                B[p.index - 1] = p.value
            elif p.ptype == &#34;c&#34;:
                q = p.index
                C[(q[0] - 1, q[1] - 1)] = p.value
            elif p.ptype == &#34;f&#34;:
                F[p.index - 1] = p.value

        results = [scalars, A, B, C, F]
        ptf_index_info = self.ptf_info

        for q in ptf_index_info:
            if q is not None:
                i = ptf_index_info.index(q)
                results[q[0]][q[1]] = coords[i]

        return results

    def _predict(self, coords):
        &#34;&#34;&#34;Compute x(t) for a set of parameter values.&#34;&#34;&#34;
        dt, tsplit, datalen = self.dt, self.tsplit, self.datalen
        na, nb, cn, cm, = self.alens

        epx0v0_simu, A_simu, B_simu, C_simu, F_simu = (
                                        self._setup_simulation_arrays(coords))

        ep_simu, x0v0_simu = epx0v0_simu[0], epx0v0_simu[1:3]

        return simulation(x0v0_simu, A_simu, B_simu, C_simu, F_simu,
                          dt, tsplit * datalen, na, nb, cn, cm
                          )[::tsplit] + ep_simu

    # mcmc stuff

    def _log_prior(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic prior of a set of parameter values.&#34;&#34;&#34;
        result = 1
        for i in range(self.ndim):
            prob = self.priors_array[i](coefs[i])
            if prob &lt;= 0:
                return -np.inf
            else:
                result = result * prob
        return np.log(result)

    def _log_likelihood(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic likelihood of a set of parameter values.&#34;&#34;&#34;
        prediction = self._predict(coefs)
        if not np.isfinite(prediction[-1]):
            return -np.inf

        if self.fx_fix:
            log_fx = coefs[self.log_fx_loc]
            s2 = self.x_unc ** 2 + prediction ** 2 * np.exp(2 * log_fx)
            ll = - 0.5 * np.sum((prediction - self.x_data) ** 2 / s2 +
                                np.log(s2))
        else:
            ll = - 0.5 * np.sum(((prediction - self.x_data) / self.x_unc) ** 2)
        return ll

    def _log_probability(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic probabilty of a set of parameter values.&#34;&#34;&#34;
        lp = self._log_prior(coefs)
        if not np.isfinite(lp):
            return -np.inf
        return lp + self._log_likelihood(coefs)

    def setup_sampler(self, n_walkers, burn_iter, main_iter):
        &#34;&#34;&#34;
        Set up the `emcee` Sampler object and run the MCMC chain.

        See `emcee` docs for more details.

        Parameters such as the number of CPU cores and `emcee` moves used by
        the sampler can be changed from the model attributes before running
        this method. See the full docs of the model classes for more details.

        Parameters
        ----------
        n_walkers : int
            the number of walkers in the MCMC chain. See `emcee` docs for more
            details.
        burn_iter : int
            the number of steps that your chain will do during the burn in
            phase. The samples produced during burn in phase are discarded.
        main_iter : int
            the number of steps that your chain will do during the production
            phase. The samples produced during production phase are saved in
            the sampler and can be extracted for later analysis.

        Returns
        -------
        sampler : emcee Sampler instance
            Returns the `emcee` ensemble sampler after running MCMC. See
            `emcee` docs for more details.
        &#34;&#34;&#34;
        p0 = [self.mcmc_initvals + 1e-7 * np.random.randn(self.ndim)
              for i in range(n_walkers)]

        with Pool(processes=self.cpu_cores) as pool:
            sampler = emcee.EnsembleSampler(n_walkers, self.ndim,
                                            self._log_probability,
                                            moves=self.mcmc_moves, pool=pool)

            print(&#34;&#34;)
            print(&#34;Running burn-in...&#34;)
            p0, _, _ = sampler.run_mcmc(p0, burn_iter, progress=True)
            sampler.reset()

            print(&#34;&#34;)
            print(&#34;Running production...&#34;)
            pos, prob, state = sampler.run_mcmc(p0, main_iter, progress=True)

            return sampler

    # tools

    def update_initvals(self, newinivalues):
        &#34;&#34;&#34;
        Update the starting values of the MCMC chain.

        Update the initial values of the MCMC chain stored in the `tsaopy`
        model instance `mcmc_initvals` attribute. Default is a list with the
        value attribute for each parameter supplied to the model at
        initialization.

        This attribute is supplied to the `emcee` Sampler object when
        `setup_sampler`.

        Parameters
        ----------
        newinivalues : list or array
            the new values for the initial  values of the MCMC chain. The
            elements must be passed in the same order than the parameters
            arg that was passed when initializing the model.
        &#34;&#34;&#34;
        self.mcmc_initvals = newinivalues

    def set_mcmc_moves(self, moves):
        &#34;&#34;&#34;
        Change the `emcee` moves used in the MCMC run.

        Set the mcmc_moves attribute in the `tsaopy` model instance. Default is
        None. This attribute is supplied to the `emcee` Sampler object when the
        setup_sampler method of the `tsaopy` model object is called. It&#39;s
        possible to run MCMC chains for the same model with different moves by
        updating the attribute with this method before each chain is run.

        Parameters
        ----------
        moves : emcee moves instance
            the `emcee` moves instance to be supplied to the sampler.


        &#34;&#34;&#34;
        self.mcmc_moves = moves

    def set_cpu_cores(self, cores):
        &#34;&#34;&#34;
        Set the number of CPU cores used by the emcee sampler.

        Set the cpu_cores attribute in the `tsaopy` model instance. Default is
        the total number of cores in the system, obtained with
        `multiprocessing.cpu_count`, minus two, or one if `cpu_count` returns 2
        or less.

        This attribute is supplied to the emcee Sampler object when you call
        the setup_sampler method of the tsaopy model object.

        Parameters
        ----------
        cores : int
            number of CPU cores to be used by the `emcee` sampler.
        &#34;&#34;&#34;
        self.cpu_cores = cores

    def update_tsplit(self, newtsplit):
        &#34;&#34;&#34;
        Change the integration time in simulations.

        Set the `tsplit` attribute in the `tsaopy` model instance, which is
        used to set the time step for the numerical integrations.

        The time step in the numerical integration is computed as

        dt = (tf - t0)/(ndata-1)/tsplit

        This means that the time step is obtained by dividing the difference
        between consecutive t values over `tsplit`. Default value is 4.
        Users that want to improve computing time may reduce this attribute
        to 3, 2, or 1, at the expense of a possible precission loss in the
        numerical simulations.

        Parameters
        ----------
        newtsplit : int
            the new value for tsplit that will also update the integration
            time step.
        &#34;&#34;&#34;
        self.tsplit = newtsplit
        self.dt = (self.t_data[-1] - self.t0) / (
                                                self.datalen - 1) / self.tsplit

    def neg_ll(self, coords):
        &#34;&#34;&#34;
        Compute the negative logarithmic likelihood.

        Compute the negative logarithmic likelihood for a set of parameter
        values for the defined model. This is best used when optimizing the
        initial values with an external optimizer.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.

        Returns
        -------
        float
            value of `neg_ll` for the given parameter values.

        Examples
        -------
            f_to_minimize = my_model.neg_ll
            external_function_minimizer(f_to_minimize, *args)
        &#34;&#34;&#34;
        return -self._log_likelihood(coords)

    # plots

    def plot_measurements(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
            )
        plt.legend()
        plt.show()

    def plot_simulation(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model,
        and a lineplot of a simulation using values provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
            )
        plt.plot(
            self.t_data, self._predict(coords),
            color=&#34;tab:red&#34;, label=&#34;x simulation&#34;
            )
        plt.legend()
        plt.show()

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tsaopy.models.PVModel" href="#tsaopy.models.PVModel">PVModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsaopy.models.PModel.neg_ll"><code class="name flex">
<span>def <span class="ident">neg_ll</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the negative logarithmic likelihood.</p>
<p>Compute the negative logarithmic likelihood for a set of parameter
values for the defined model. This is best used when optimizing the
initial values with an external optimizer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>list</code> or <code>array</code></dt>
<dd>values for each parameter. The elements must be passed in the same
order than the parameters arg that was passed when initializing the
model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>value of <code>neg_ll</code> for the given parameter values.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>f_to_minimize = my_model.neg_ll
external_function_minimizer(f_to_minimize, *args)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neg_ll(self, coords):
    &#34;&#34;&#34;
    Compute the negative logarithmic likelihood.

    Compute the negative logarithmic likelihood for a set of parameter
    values for the defined model. This is best used when optimizing the
    initial values with an external optimizer.

    Parameters
    ----------
    coords : list or array
        values for each parameter. The elements must be passed in the same
        order than the parameters arg that was passed when initializing the
        model.

    Returns
    -------
    float
        value of `neg_ll` for the given parameter values.

    Examples
    -------
        f_to_minimize = my_model.neg_ll
        external_function_minimizer(f_to_minimize, *args)
    &#34;&#34;&#34;
    return -self._log_likelihood(coords)</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.plot_measurements"><code class="name flex">
<span>def <span class="ident">plot_measurements</span></span>(<span>self, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing the (t,x(t)) series provided to the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_measurements(self, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing the (t,x(t)) series provided to the model.

    Parameters
    ----------
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.x_data,
        color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.plot_simulation"><code class="name flex">
<span>def <span class="ident">plot_simulation</span></span>(<span>self, coords, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing the (t,x(t)) series provided to the model,
and a lineplot of a simulation using values provided in the coords arg.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>list</code> or <code>array</code></dt>
<dd>values for each parameter. The elements must be passed in the same
order than the parameters arg that was passed when initializing the
model.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_simulation(self, coords, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing the (t,x(t)) series provided to the model,
    and a lineplot of a simulation using values provided in the coords arg.

    Parameters
    ----------
    coords : list or array
        values for each parameter. The elements must be passed in the same
        order than the parameters arg that was passed when initializing the
        model.
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.x_data,
        color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
    plt.plot(
        self.t_data, self._predict(coords),
        color=&#34;tab:red&#34;, label=&#34;x simulation&#34;
        )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.set_cpu_cores"><code class="name flex">
<span>def <span class="ident">set_cpu_cores</span></span>(<span>self, cores)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the number of CPU cores used by the emcee sampler.</p>
<p>Set the cpu_cores attribute in the <code><a title="tsaopy" href="index.html">tsaopy</a></code> model instance. Default is
the total number of cores in the system, obtained with
<code>multiprocessing.cpu_count</code>, minus two, or one if <code>cpu_count</code> returns 2
or less.</p>
<p>This attribute is supplied to the emcee Sampler object when you call
the setup_sampler method of the tsaopy model object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cores</code></strong> :&ensp;<code>int</code></dt>
<dd>number of CPU cores to be used by the <code>emcee</code> sampler.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cpu_cores(self, cores):
    &#34;&#34;&#34;
    Set the number of CPU cores used by the emcee sampler.

    Set the cpu_cores attribute in the `tsaopy` model instance. Default is
    the total number of cores in the system, obtained with
    `multiprocessing.cpu_count`, minus two, or one if `cpu_count` returns 2
    or less.

    This attribute is supplied to the emcee Sampler object when you call
    the setup_sampler method of the tsaopy model object.

    Parameters
    ----------
    cores : int
        number of CPU cores to be used by the `emcee` sampler.
    &#34;&#34;&#34;
    self.cpu_cores = cores</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.set_mcmc_moves"><code class="name flex">
<span>def <span class="ident">set_mcmc_moves</span></span>(<span>self, moves)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the <code>emcee</code> moves used in the MCMC run.</p>
<p>Set the mcmc_moves attribute in the <code><a title="tsaopy" href="index.html">tsaopy</a></code> model instance. Default is
None. This attribute is supplied to the <code>emcee</code> Sampler object when the
setup_sampler method of the <code><a title="tsaopy" href="index.html">tsaopy</a></code> model object is called. It's
possible to run MCMC chains for the same model with different moves by
updating the attribute with this method before each chain is run.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>moves</code></strong> :&ensp;<code>emcee moves instance</code></dt>
<dd>the <code>emcee</code> moves instance to be supplied to the sampler.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mcmc_moves(self, moves):
    &#34;&#34;&#34;
    Change the `emcee` moves used in the MCMC run.

    Set the mcmc_moves attribute in the `tsaopy` model instance. Default is
    None. This attribute is supplied to the `emcee` Sampler object when the
    setup_sampler method of the `tsaopy` model object is called. It&#39;s
    possible to run MCMC chains for the same model with different moves by
    updating the attribute with this method before each chain is run.

    Parameters
    ----------
    moves : emcee moves instance
        the `emcee` moves instance to be supplied to the sampler.


    &#34;&#34;&#34;
    self.mcmc_moves = moves</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.setup_sampler"><code class="name flex">
<span>def <span class="ident">setup_sampler</span></span>(<span>self, n_walkers, burn_iter, main_iter)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up the <code>emcee</code> Sampler object and run the MCMC chain.</p>
<p>See <code>emcee</code> docs for more details.</p>
<p>Parameters such as the number of CPU cores and <code>emcee</code> moves used by
the sampler can be changed from the model attributes before running
this method. See the full docs of the model classes for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_walkers</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of walkers in the MCMC chain. See <code>emcee</code> docs for more
details.</dd>
<dt><strong><code>burn_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of steps that your chain will do during the burn in
phase. The samples produced during burn in phase are discarded.</dd>
<dt><strong><code>main_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of steps that your chain will do during the production
phase. The samples produced during production phase are saved in
the sampler and can be extracted for later analysis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sampler</code></strong> :&ensp;<code>emcee Sampler instance</code></dt>
<dd>Returns the <code>emcee</code> ensemble sampler after running MCMC. See
<code>emcee</code> docs for more details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_sampler(self, n_walkers, burn_iter, main_iter):
    &#34;&#34;&#34;
    Set up the `emcee` Sampler object and run the MCMC chain.

    See `emcee` docs for more details.

    Parameters such as the number of CPU cores and `emcee` moves used by
    the sampler can be changed from the model attributes before running
    this method. See the full docs of the model classes for more details.

    Parameters
    ----------
    n_walkers : int
        the number of walkers in the MCMC chain. See `emcee` docs for more
        details.
    burn_iter : int
        the number of steps that your chain will do during the burn in
        phase. The samples produced during burn in phase are discarded.
    main_iter : int
        the number of steps that your chain will do during the production
        phase. The samples produced during production phase are saved in
        the sampler and can be extracted for later analysis.

    Returns
    -------
    sampler : emcee Sampler instance
        Returns the `emcee` ensemble sampler after running MCMC. See
        `emcee` docs for more details.
    &#34;&#34;&#34;
    p0 = [self.mcmc_initvals + 1e-7 * np.random.randn(self.ndim)
          for i in range(n_walkers)]

    with Pool(processes=self.cpu_cores) as pool:
        sampler = emcee.EnsembleSampler(n_walkers, self.ndim,
                                        self._log_probability,
                                        moves=self.mcmc_moves, pool=pool)

        print(&#34;&#34;)
        print(&#34;Running burn-in...&#34;)
        p0, _, _ = sampler.run_mcmc(p0, burn_iter, progress=True)
        sampler.reset()

        print(&#34;&#34;)
        print(&#34;Running production...&#34;)
        pos, prob, state = sampler.run_mcmc(p0, main_iter, progress=True)

        return sampler</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.update_initvals"><code class="name flex">
<span>def <span class="ident">update_initvals</span></span>(<span>self, newinivalues)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the starting values of the MCMC chain.</p>
<p>Update the initial values of the MCMC chain stored in the <code><a title="tsaopy" href="index.html">tsaopy</a></code>
model instance <code>mcmc_initvals</code> attribute. Default is a list with the
value attribute for each parameter supplied to the model at
initialization.</p>
<p>This attribute is supplied to the <code>emcee</code> Sampler object when
<code>setup_sampler</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>newinivalues</code></strong> :&ensp;<code>list</code> or <code>array</code></dt>
<dd>the new values for the initial
values of the MCMC chain. The
elements must be passed in the same order than the parameters
arg that was passed when initializing the model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_initvals(self, newinivalues):
    &#34;&#34;&#34;
    Update the starting values of the MCMC chain.

    Update the initial values of the MCMC chain stored in the `tsaopy`
    model instance `mcmc_initvals` attribute. Default is a list with the
    value attribute for each parameter supplied to the model at
    initialization.

    This attribute is supplied to the `emcee` Sampler object when
    `setup_sampler`.

    Parameters
    ----------
    newinivalues : list or array
        the new values for the initial  values of the MCMC chain. The
        elements must be passed in the same order than the parameters
        arg that was passed when initializing the model.
    &#34;&#34;&#34;
    self.mcmc_initvals = newinivalues</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PModel.update_tsplit"><code class="name flex">
<span>def <span class="ident">update_tsplit</span></span>(<span>self, newtsplit)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the integration time in simulations.</p>
<p>Set the <code>tsplit</code> attribute in the <code><a title="tsaopy" href="index.html">tsaopy</a></code> model instance, which is
used to set the time step for the numerical integrations.</p>
<p>The time step in the numerical integration is computed as</p>
<p>dt = (tf - t0)/(ndata-1)/tsplit</p>
<p>This means that the time step is obtained by dividing the difference
between consecutive t values over <code>tsplit</code>. Default value is 4.
Users that want to improve computing time may reduce this attribute
to 3, 2, or 1, at the expense of a possible precission loss in the
numerical simulations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>newtsplit</code></strong> :&ensp;<code>int</code></dt>
<dd>the new value for tsplit that will also update the integration
time step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tsplit(self, newtsplit):
    &#34;&#34;&#34;
    Change the integration time in simulations.

    Set the `tsplit` attribute in the `tsaopy` model instance, which is
    used to set the time step for the numerical integrations.

    The time step in the numerical integration is computed as

    dt = (tf - t0)/(ndata-1)/tsplit

    This means that the time step is obtained by dividing the difference
    between consecutive t values over `tsplit`. Default value is 4.
    Users that want to improve computing time may reduce this attribute
    to 3, 2, or 1, at the expense of a possible precission loss in the
    numerical simulations.

    Parameters
    ----------
    newtsplit : int
        the new value for tsplit that will also update the integration
        time step.
    &#34;&#34;&#34;
    self.tsplit = newtsplit
    self.dt = (self.t_data[-1] - self.t0) / (
                                            self.datalen - 1) / self.tsplit</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsaopy.models.PVModel"><code class="flex name class">
<span>class <span class="ident">PVModel</span></span>
<span>(</span><span>parameters, t_data, x_data, v_data, x_unc, v_unc)</span>
</code></dt>
<dd>
<div class="desc"><p>Build <code><a title="tsaopy" href="index.html">tsaopy</a></code> model object.</p>
<p>This object condenses all necessary variables to set up the ODE according
to the parameters provided plus the MCMC configuration to do the fitting.</p>
<p>It includes some QOL methods suchs as changing the initial values of the
chain, the time step for the simulations, the number of CPU cores used
during simulations, and type of emcee moves used in the MCMC chain. It also
includes some plotting methods.</p>
<p>This class fits the parameters to both x(t) and v(t) data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list</code></dt>
<dd>the list of parameters that will be considered in the model. There
must be at least three parameters including the initial conditions
and one ODE coefficient. There can't be repeated parameters (two
parameters having the same ptype and index).</dd>
<dt><strong><code>t_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with the time axis of the measurements.</dd>
<dt><strong><code>x_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with the position measurements.</dd>
<dt><strong><code>v_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with the velocity measurements. Note that there can't be a
scale factor between x(t) and v(t), v(t) must be exactly equal
to the time derivative of x(t).</dd>
<dt><strong><code>x_unc</code></strong> :&ensp;<code>float</code> or <code>int,</code> or <code>array</code></dt>
<dd>uncertainty of the x(t) measurements. It can be either a single
number representing the uncertainty of all measurements or an array
of the same length as <code>x_data</code> with a unique value for each
measurement.</dd>
<dt><strong><code>v_unc</code></strong> :&ensp;<code>float</code> or <code>int,</code> or <code>array</code></dt>
<dd>same as <code>x_unc</code> but for v(t) measurements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PVModel(PModel):
    &#34;&#34;&#34;
    Build `tsaopy` model object.

    This object condenses all necessary variables to set up the ODE according
    to the parameters provided plus the MCMC configuration to do the fitting.

    It includes some QOL methods suchs as changing the initial values of the
    chain, the time step for the simulations, the number of CPU cores used
    during simulations, and type of emcee moves used in the MCMC chain. It also
    includes some plotting methods.

    This class fits the parameters to both x(t) and v(t) data.
    &#34;&#34;&#34;

    def __init__(self, parameters, t_data, x_data, v_data, x_unc, v_unc):
        &#34;&#34;&#34;
        Parameters
        ----------
        parameters : list
            the list of parameters that will be considered in the model. There
            must be at least three parameters including the initial conditions
            and one ODE coefficient. There can&#39;t be repeated parameters (two
            parameters having the same ptype and index).
        t_data : array
            array with the time axis of the measurements.
        x_data : array
            array with the position measurements.
        v_data : array
            array with the velocity measurements. Note that there can&#39;t be a
            scale factor between x(t) and v(t), v(t) must be exactly equal
            to the time derivative of x(t).
        x_unc : float or int, or array
            uncertainty of the x(t) measurements. It can be either a single
            number representing the uncertainty of all measurements or an array
            of the same length as `x_data` with a unique value for each
            measurement.
        v_unc : float or int, or array
            same as `x_unc` but for v(t) measurements.
        &#34;&#34;&#34;
        super().__init__(parameters, t_data, x_data, x_unc)
        self.v_data = v_data
        self.v_unc = v_unc
        self.fv_fix = False
        for p in self.params_to_fit:
            if p.ptype == &#39;log_fv&#39;:
                self.fv_fix = True
                self.log_fv_loc = self.params_to_fit.index(p)

    def _predict(self, coords):
        &#34;&#34;&#34;Compute x(t) and v(t) for a set of parameter values.&#34;&#34;&#34;
        dt, tsplit, datalen = self.dt, self.tsplit, self.datalen
        na, nb, cn, cm, = self.alens

        epx0v0_simu, A_simu, B_simu, C_simu, F_simu = (
                                        self._setup_simulation_arrays(coords))

        ep_simu, x0v0_simu = epx0v0_simu[0], epx0v0_simu[1:]

        simu_result = simulationv(x0v0_simu, A_simu, B_simu, C_simu, F_simu,
                                  dt, tsplit * datalen, na, nb, cn,
                                  cm)[::tsplit]

        simu_result[:, 0] = simu_result[:, 0] + ep_simu
        return simu_result

    def _log_likelihood(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic likelihood of a set of parameter values.&#34;&#34;&#34;
        prediction = self._predict(coefs)
        predx, predv = prediction[:, 0], prediction[:, 1]
        if not np.isfinite(predv[-1]):
            return -np.inf

        if self.fx_fix:
            log_fx = coefs[self.log_fx_loc]
            s2_x = self.x_unc ** 2 + predx ** 2 * np.exp(2 * log_fx)
            ll = - 0.5 * np.sum((predx - self.x_data) ** 2 / s2_x +
                                np.log(s2_x))
        else:
            ll = - 0.5 * np.sum(((predx - self.x_data) / self.x_unc) ** 2)

        if self.fv_fix:
            log_fv = coefs[self.log_fv_loc]
            s2_v = self.v_unc ** 2 + predv ** 2 * np.exp(2 * log_fv)
            ll = ll - 0.5 * np.sum((predv - self.v_data) ** 2 / s2_v +
                                   np.log(s2_v))
        else:
            ll = ll - 0.5 * np.sum(((predv - self.v_data) / self.v_unc) ** 2)

        return ll

    def _log_probability(self, coefs):
        &#34;&#34;&#34;Compute the logarithmic probability of a set of parameter values.&#34;&#34;&#34;
        lp = self._log_prior(coefs)
        if not np.isfinite(lp):
            return -np.inf
        return lp + self._log_likelihood(coefs)

    def setup_sampler(self, n_walkers, burn_iter, main_iter):
        &#34;&#34;&#34;
        Set up the `emcee` Sampler object and run the MCMC chain.

        See `emcee` docs for more details.

        Parameters such as the number of CPU cores and `emcee` moves used by
        the sampler can be changed from the model attributes before running
        this method. See the full docs of the model classes for more details.

        Parameters
        ----------
        n_walkers : int
            the number of walkers in the MCMC chain. See `emcee` docs for more
            details.
        burn_iter : int
            the number of steps that your chain will do during the burn in
            phase. The samples produced during burn in phase are discarded.
        main_iter : int
            the number of steps that your chain will do during the production
            phase. The samples produced during production phase are saved in
            the sampler and can be extracted for later analysis.

        Returns
        -------
        sampler : emcee Sampler instance
            Returns the `emcee` ensemble sampler after running MCMC. See
            `emcee` docs for more details.
        &#34;&#34;&#34;
        p0 = [self.mcmc_initvals + 1e-7 * np.random.randn(self.ndim)
              for i in range(n_walkers)]

        with Pool(processes=self.cpu_cores) as pool:
            sampler = emcee.EnsembleSampler(n_walkers, self.ndim,
                                            self._log_probability,
                                            moves=self.mcmc_moves, pool=pool)

            print(&#34;&#34;)
            print(&#34;Running burn-in...&#34;)
            p0, _, _ = sampler.run_mcmc(p0, burn_iter, progress=True)
            sampler.reset()

            print(&#34;&#34;)
            print(&#34;Running production...&#34;)
            pos, prob, state = sampler.run_mcmc(p0, main_iter, progress=True)

            return sampler

    # tools

    def neg_ll(self, coords):
        &#34;&#34;&#34;See docs for PModel.&#34;&#34;&#34;
        return -self._log_likelihood(coords)

    # plots

    def plot_measurements(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
        provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.legend()
        plt.show()

    def plot_measurements_x(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.legend()
        plt.show()

    def plot_measurements_v(self, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,v(t)) series provided to the model.

        Parameters
        ----------
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.legend()
        plt.show()

    def plot_simulation(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
        provided to the model, and lineplots of a simulation using values
        provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 0],
            color=&#34;tab:red&#34;,
            label=&#34;x simulation&#34;,
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 1],
            color=&#34;tab:purple&#34;,
            label=&#34;v simulation&#34;,
        )
        plt.legend()
        plt.show()

    def plot_simulation_x(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,x(t)) series provided to the model,
        and a lineplot of a simulation using values provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.x_data,
            color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 0],
            color=&#34;tab:red&#34;,
            label=&#34;x simulation&#34;,
        )
        plt.legend()
        plt.show()

    def plot_simulation_v(self, coords, figsize=(7, 5), dpi=100):
        &#34;&#34;&#34;
        Make a scatterplot showing the (t,v(t)) series provided to the model,
        and a lineplot of a simulation using values provided in the coords arg.

        Parameters
        ----------
        coords : list or array
            values for each parameter. The elements must be passed in the same
            order than the parameters arg that was passed when initializing the
            model.
        figsize : tuple, optional
            proportions of the image passed to pyplot. The default is (7, 5).
        dpi : TYPE, optional
            dots per inch passed to pyplot. The default is 100.

        Returns
        -------
        Displays created figures.
        &#34;&#34;&#34;
        plt.figure(figsize=figsize, dpi=dpi)
        plt.scatter(
            self.t_data, self.v_data,
            color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
        )
        plt.plot(
            self.t_data,
            self._predict(coords)[:, 1],
            color=&#34;tab:purple&#34;,
            label=&#34;v simulation&#34;,
        )
        plt.legend()
        plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tsaopy.models.PModel" href="#tsaopy.models.PModel">PModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsaopy.models.PVModel.neg_ll"><code class="name flex">
<span>def <span class="ident">neg_ll</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<div class="desc"><p>See docs for PModel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neg_ll(self, coords):
    &#34;&#34;&#34;See docs for PModel.&#34;&#34;&#34;
    return -self._log_likelihood(coords)</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PVModel.plot_measurements"><code class="name flex">
<span>def <span class="ident">plot_measurements</span></span>(<span>self, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
provided to the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_measurements(self, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
    provided to the model.

    Parameters
    ----------
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.x_data,
        color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
    )
    plt.scatter(
        self.t_data, self.v_data,
        color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
    )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PVModel.plot_measurements_v"><code class="name flex">
<span>def <span class="ident">plot_measurements_v</span></span>(<span>self, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing the (t,v(t)) series provided to the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_measurements_v(self, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing the (t,v(t)) series provided to the model.

    Parameters
    ----------
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.v_data,
        color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
    )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PVModel.plot_measurements_x"><code class="name flex">
<span>def <span class="ident">plot_measurements_x</span></span>(<span>self, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing the (t,x(t)) series provided to the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_measurements_x(self, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing the (t,x(t)) series provided to the model.

    Parameters
    ----------
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.x_data,
        color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
    )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PVModel.plot_simulation"><code class="name flex">
<span>def <span class="ident">plot_simulation</span></span>(<span>self, coords, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
provided to the model, and lineplots of a simulation using values
provided in the coords arg.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>list</code> or <code>array</code></dt>
<dd>values for each parameter. The elements must be passed in the same
order than the parameters arg that was passed when initializing the
model.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_simulation(self, coords, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing both the (t,x(t)) and (t,v(t)) series
    provided to the model, and lineplots of a simulation using values
    provided in the coords arg.

    Parameters
    ----------
    coords : list or array
        values for each parameter. The elements must be passed in the same
        order than the parameters arg that was passed when initializing the
        model.
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.x_data,
        color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
    )
    plt.scatter(
        self.t_data, self.v_data,
        color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
    )
    plt.plot(
        self.t_data,
        self._predict(coords)[:, 0],
        color=&#34;tab:red&#34;,
        label=&#34;x simulation&#34;,
    )
    plt.plot(
        self.t_data,
        self._predict(coords)[:, 1],
        color=&#34;tab:purple&#34;,
        label=&#34;v simulation&#34;,
    )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PVModel.plot_simulation_v"><code class="name flex">
<span>def <span class="ident">plot_simulation_v</span></span>(<span>self, coords, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing the (t,v(t)) series provided to the model,
and a lineplot of a simulation using values provided in the coords arg.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>list</code> or <code>array</code></dt>
<dd>values for each parameter. The elements must be passed in the same
order than the parameters arg that was passed when initializing the
model.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_simulation_v(self, coords, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing the (t,v(t)) series provided to the model,
    and a lineplot of a simulation using values provided in the coords arg.

    Parameters
    ----------
    coords : list or array
        values for each parameter. The elements must be passed in the same
        order than the parameters arg that was passed when initializing the
        model.
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.v_data,
        color=&#34;tab:blue&#34;, s=1.0, label=&#34;v measurements&#34;
    )
    plt.plot(
        self.t_data,
        self._predict(coords)[:, 1],
        color=&#34;tab:purple&#34;,
        label=&#34;v simulation&#34;,
    )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="tsaopy.models.PVModel.plot_simulation_x"><code class="name flex">
<span>def <span class="ident">plot_simulation_x</span></span>(<span>self, coords, figsize=(7, 5), dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a scatterplot showing the (t,x(t)) series provided to the model,
and a lineplot of a simulation using values provided in the coords arg.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>list</code> or <code>array</code></dt>
<dd>values for each parameter. The elements must be passed in the same
order than the parameters arg that was passed when initializing the
model.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>proportions of the image passed to pyplot. The default is (7, 5).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>dots per inch passed to pyplot. The default is 100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Displays created figures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_simulation_x(self, coords, figsize=(7, 5), dpi=100):
    &#34;&#34;&#34;
    Make a scatterplot showing the (t,x(t)) series provided to the model,
    and a lineplot of a simulation using values provided in the coords arg.

    Parameters
    ----------
    coords : list or array
        values for each parameter. The elements must be passed in the same
        order than the parameters arg that was passed when initializing the
        model.
    figsize : tuple, optional
        proportions of the image passed to pyplot. The default is (7, 5).
    dpi : TYPE, optional
        dots per inch passed to pyplot. The default is 100.

    Returns
    -------
    Displays created figures.
    &#34;&#34;&#34;
    plt.figure(figsize=figsize, dpi=dpi)
    plt.scatter(
        self.t_data, self.x_data,
        color=&#34;black&#34;, s=1.0, label=&#34;x measurements&#34;
    )
    plt.plot(
        self.t_data,
        self._predict(coords)[:, 0],
        color=&#34;tab:red&#34;,
        label=&#34;x simulation&#34;,
    )
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tsaopy.models.PModel" href="#tsaopy.models.PModel">PModel</a></b></code>:
<ul class="hlist">
<li><code><a title="tsaopy.models.PModel.set_cpu_cores" href="#tsaopy.models.PModel.set_cpu_cores">set_cpu_cores</a></code></li>
<li><code><a title="tsaopy.models.PModel.set_mcmc_moves" href="#tsaopy.models.PModel.set_mcmc_moves">set_mcmc_moves</a></code></li>
<li><code><a title="tsaopy.models.PModel.setup_sampler" href="#tsaopy.models.PModel.setup_sampler">setup_sampler</a></code></li>
<li><code><a title="tsaopy.models.PModel.update_initvals" href="#tsaopy.models.PModel.update_initvals">update_initvals</a></code></li>
<li><code><a title="tsaopy.models.PModel.update_tsplit" href="#tsaopy.models.PModel.update_tsplit">update_tsplit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsaopy" href="index.html">tsaopy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tsaopy.models.PModel" href="#tsaopy.models.PModel">PModel</a></code></h4>
<ul class="two-column">
<li><code><a title="tsaopy.models.PModel.neg_ll" href="#tsaopy.models.PModel.neg_ll">neg_ll</a></code></li>
<li><code><a title="tsaopy.models.PModel.plot_measurements" href="#tsaopy.models.PModel.plot_measurements">plot_measurements</a></code></li>
<li><code><a title="tsaopy.models.PModel.plot_simulation" href="#tsaopy.models.PModel.plot_simulation">plot_simulation</a></code></li>
<li><code><a title="tsaopy.models.PModel.set_cpu_cores" href="#tsaopy.models.PModel.set_cpu_cores">set_cpu_cores</a></code></li>
<li><code><a title="tsaopy.models.PModel.set_mcmc_moves" href="#tsaopy.models.PModel.set_mcmc_moves">set_mcmc_moves</a></code></li>
<li><code><a title="tsaopy.models.PModel.setup_sampler" href="#tsaopy.models.PModel.setup_sampler">setup_sampler</a></code></li>
<li><code><a title="tsaopy.models.PModel.update_initvals" href="#tsaopy.models.PModel.update_initvals">update_initvals</a></code></li>
<li><code><a title="tsaopy.models.PModel.update_tsplit" href="#tsaopy.models.PModel.update_tsplit">update_tsplit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsaopy.models.PVModel" href="#tsaopy.models.PVModel">PVModel</a></code></h4>
<ul class="two-column">
<li><code><a title="tsaopy.models.PVModel.neg_ll" href="#tsaopy.models.PVModel.neg_ll">neg_ll</a></code></li>
<li><code><a title="tsaopy.models.PVModel.plot_measurements" href="#tsaopy.models.PVModel.plot_measurements">plot_measurements</a></code></li>
<li><code><a title="tsaopy.models.PVModel.plot_measurements_v" href="#tsaopy.models.PVModel.plot_measurements_v">plot_measurements_v</a></code></li>
<li><code><a title="tsaopy.models.PVModel.plot_measurements_x" href="#tsaopy.models.PVModel.plot_measurements_x">plot_measurements_x</a></code></li>
<li><code><a title="tsaopy.models.PVModel.plot_simulation" href="#tsaopy.models.PVModel.plot_simulation">plot_simulation</a></code></li>
<li><code><a title="tsaopy.models.PVModel.plot_simulation_v" href="#tsaopy.models.PVModel.plot_simulation_v">plot_simulation_v</a></code></li>
<li><code><a title="tsaopy.models.PVModel.plot_simulation_x" href="#tsaopy.models.PVModel.plot_simulation_x">plot_simulation_x</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>